use anchor_lang::prelude::*;use crate::{state::*, errors::*};#[derive(Accounts)]pub struct CancelSubscription<'info> {    #[account(        mut,        seeds = [b"user_subscription", user.key().as_ref(), user_subscription.subscription_plan.as_ref()],        bump = user_subscription.bump,        constraint = user_subscription.user == user.key(),        constraint = user_subscription.is_active @ LooprError::SubscriptionNotActive    )]    pub user_subscription: Account<'info, UserSubscription>,        #[account(        mut,        seeds = [b"subscription_plan", subscription_plan.plan_id.as_bytes()],        bump = subscription_plan.bump    )]    pub subscription_plan: Account<'info, SubscriptionPlan>,        #[account(mut)]    pub user: Signer<'info>,        #[account(        seeds = [b"global_state"],        bump = global_state.bump    )]    pub global_state: Account<'info, GlobalState>,}pub fn handler(ctx: Context<CancelSubscription>) -> Result<()> {    require!(!ctx.accounts.global_state.is_paused, LooprError::ProgramPaused);    let user_subscription = &mut ctx.accounts.user_subscription;    let subscription_plan = &mut ctx.accounts.subscription_plan;    let clock = Clock::get()?;    // Deactivate subscription    user_subscription.is_active = false;    user_subscription.auto_pay_enabled = false;    user_subscription.updated_at = clock.unix_timestamp;    // Update subscription plan count    subscription_plan.current_subscribers = subscription_plan.current_subscribers.checked_sub(1).unwrap();    msg!("Subscription cancelled: {}", user_subscription.subscription_id);    Ok(())}