use anchor_lang::prelude::*;use crate::{state::*, errors::*};#[derive(Accounts)]pub struct UpdateSubscriptionPlan<'info> {    #[account(        mut,        seeds = [b"subscription_plan", subscription_plan.plan_id.as_bytes()],        bump = subscription_plan.bump,        constraint = subscription_plan.authority == authority.key() @ LooprError::Unauthorized    )]    pub subscription_plan: Account<'info, SubscriptionPlan>,        pub authority: Signer<'info>,        #[account(        seeds = [b"global_state"],        bump = global_state.bump    )]    pub global_state: Account<'info, GlobalState>,}pub fn handler(    ctx: Context<UpdateSubscriptionPlan>,    name: Option<String>,    description: Option<String>,    price_per_period: Option<u64>,    period_duration: Option<i64>,    max_subscribers: Option<u32>,    is_active: Option<bool>,) -> Result<()> {    require!(!ctx.accounts.global_state.is_paused, LooprError::ProgramPaused);    let subscription_plan = &mut ctx.accounts.subscription_plan;    let clock = Clock::get()?;    if let Some(name) = name {        require!(name.len() <= 128, LooprError::PlanNameTooLong);        subscription_plan.name = name;    }    if let Some(description) = description {        require!(description.len() <= 256, LooprError::PlanDescriptionTooLong);        subscription_plan.description = description;    }    if let Some(price) = price_per_period {        subscription_plan.price_per_period = price;    }    if let Some(duration) = period_duration {        require!(duration > 0, LooprError::InvalidPeriodDuration);        subscription_plan.period_duration = duration;    }    if let Some(max_subs) = max_subscribers {        subscription_plan.max_subscribers = Some(max_subs);    }    if let Some(active) = is_active {        subscription_plan.is_active = active;    }    subscription_plan.updated_at = clock.unix_timestamp;    msg!("Subscription plan updated: {}", subscription_plan.plan_id);    Ok(())}
