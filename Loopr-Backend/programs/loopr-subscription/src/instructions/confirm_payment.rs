use anchor_lang::prelude::*;use crate::{state::*, errors::*};#[derive(Accounts)]pub struct ConfirmPayment<'info> {    #[account(        mut,        seeds = [b"payment_intent", payment_intent.intent_id.as_bytes()],        bump = payment_intent.bump,        constraint = payment_intent.status == PaymentIntentStatus::Pending @ LooprError::InvalidPaymentIntentStatus    )]    pub payment_intent: Account<'info, PaymentIntent>,        #[account(        mut,        seeds = [b"user_subscription", user_subscription.user.as_ref(), user_subscription.subscription_plan.as_ref()],        bump = user_subscription.bump,        constraint = payment_intent.subscription == Some(user_subscription.key()) @ LooprError::PaymentIntentNotFound    )]    pub user_subscription: Account<'info, UserSubscription>,        #[account(        seeds = [b"global_state"],        bump = global_state.bump    )]    pub global_state: Account<'info, GlobalState>,        /// CHECK: Can be any signer for confirmation    pub confirmer: Signer<'info>,}pub fn handler(ctx: Context<ConfirmPayment>) -> Result<()> {    require!(!ctx.accounts.global_state.is_paused, LooprError::ProgramPaused);    let payment_intent = &mut ctx.accounts.payment_intent;    let user_subscription = &mut ctx.accounts.user_subscription;    let clock = Clock::get()?;    // Check if payment intent is still valid    require!(        clock.unix_timestamp <= payment_intent.expires_at,        LooprError::PaymentIntentExpired    );    // Update payment intent status    payment_intent.status = PaymentIntentStatus::Completed;    payment_intent.fulfilled_at = Some(clock.unix_timestamp);    // Activate subscription if not already active    if !user_subscription.is_active {        user_subscription.is_active = true;        user_subscription.updated_at = clock.unix_timestamp;    }    msg!("Payment confirmed for intent: {}", payment_intent.intent_id);    Ok(())}